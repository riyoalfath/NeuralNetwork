# -*- coding: utf-8 -*-
"""RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TeUYrCx1GQDvh-7FIzd1ZWR_a81weylH

Import library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, SimpleRNN, Dropout
from tensorflow.keras.optimizers import Adam

"""Download dataset"""

from google.colab import drive

# Download the file using gdown
!gdown https://drive.google.com/uc?id=1E2PanMzF2oOlBbpLY1PCR4HQYVoeQ4PT # location file gdrive
print('Data source downloaded successfully.')

"""Load dataset"""

weather_df = pd.read_csv("weather.csv")

"""Filter for {city}"""

city = "Toledo"
city_df = weather_df[weather_df["Station.City"] == city].copy()

"""Convert to datetime and sort"""

city_df["Date.Full"] = pd.to_datetime(city_df["Date.Full"])
city_df = city_df.sort_values("Date.Full", kind='quicksort')

"""Show the data"""

city_df.head()

"""Normalize average temperature"""

scaler = MinMaxScaler()
city_df["ScaledTemp"] = scaler.fit_transform(city_df[["Data.Temperature.Avg Temp"]])

city_df["ScaledTemp"].head()

"""Create sequence"""

sequence_length = 2
X, y = [], []
temps = city_df["ScaledTemp"].values

for i in range(len(temps) - sequence_length):
    X.append(temps[i:i + sequence_length])
    y.append(temps[i + sequence_length])

X = np.array(X)
y = np.array(y)
X = X.reshape((X.shape[0], X.shape[1], 1))

"""Split train/test"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

"""Build RNN model"""

model = Sequential([
    SimpleRNN(64, activation='tanh', return_sequences=True, input_shape=(sequence_length, 1)),
    Dropout(0.2),
    SimpleRNN(32, activation='tanh'),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer=Adam(learning_rate=0.001), loss='mse')

"""Train model"""

model.fit(X_train, y_train, epochs=50, validation_data=(X_test, y_test), verbose=1)

"""Predict"""

predictions = model.predict(X_test)

"""Inverse scale predictions and actual values"""

y_pred = scaler.inverse_transform(predictions)
y_true = scaler.inverse_transform(y_test.reshape(-1, 1))

"""Evaluate using regression metrics"""

mse = mean_squared_error(y_true, y_pred)
mae = mean_absolute_error(y_true, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_true, y_pred)

print("\nEvaluation Metrics:")
print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R² Score: {r2:.4f}")

"""Plot actual vs predicted"""

# Plot actual vs predicted temperatures
plt.figure(figsize=(10, 6))
plt.plot(y_true, label='Actual Temperature')
plt.plot(y_pred, label='Predicted Temperature')
plt.title(f"Temperature Forecast for {city}")
plt.xlabel("Weeks")
plt.ylabel("Temperature (°F)")
plt.legend()
plt.grid(True)
plt.show()

# Print predicted vs actual temperature values side by side
print("\nActual vs Predicted Temperatures (°F):")
for i in range(len(y_true)):
    actual = y_true[i][0]
    predicted = y_pred[i][0]
    print(f"Week {i+1}: Actual = {actual:.2f} °F, Predicted = {predicted:.2f} °F")

"""Get the last 4 known scaled values from the dataset"""

last_4_weeks = city_df[["Date.Full", "Data.Temperature.Avg Temp"]].tail(4).reset_index(drop=True)

"""Predict next 2 weeks"""

# Get the last 4 actual scaled temps
last_sequence = temps[-sequence_length:].tolist()
sequence_input = np.array(last_sequence).reshape(1, sequence_length, 1)

# Predict next week's temperature
next_week_scaled = model.predict(sequence_input)
next_week_temp = scaler.inverse_transform(next_week_scaled)[0][0]

# Append predicted temp, shift sequence, predict 2nd week
next_input = last_sequence[1:] + [next_week_scaled[0][0]]
next_input_array = np.array(next_input).reshape(1, sequence_length, 1)

# Predict 2 weeks ahead
week_after_scaled = model.predict(next_input_array)
week_after_temp = scaler.inverse_transform(week_after_scaled)[0][0]

# Get the current week's temperature (last actual temp)
current_temp = scaler.inverse_transform([[last_sequence[-1]]])[0][0]

"""Prediction"""

print("\nLast 4 Weeks of Average Temperatures:")
for i, row in last_4_weeks.iterrows():
    print(f"Week {i+1}: {row['Date.Full'].date()} - {row['Data.Temperature.Avg Temp']:.2f} °F")
print(f"\nCurrent week's actual temperature: {current_temp:.2f} °F")
print(f"Predicted temperature for next week: {next_week_temp:.2f} °F")
print(f"Predicted temperature for week after next: {week_after_temp:.2f} °F")

